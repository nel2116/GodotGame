---
title: リアクティブプロトタイプ実装計画
version: 0.1.0
status: draft
updated: 2025-06-06
tags:
  - Technical
  - Reactive
  - Prototype
linked_docs:
  - "[[../11_PlanDocs/11_10_reactive_programming_design|リアクティブプログラミング設計]]"
  - "[[14.3_ReactiveArchitectureDesign|リアクティブアーキテクチャ設計]]"
---

# リアクティブプロトタイプ実装計画

計画ドキュメント【11_10_reactive_programming_design】およびアーキテクチャ設計【14.3_ReactiveArchitectureDesign】を踏まえ、
UniRx を利用したプロトタイプ実装の手順をまとめます。

## 1. UniRx 等のライブラリ導入

- NuGet もしくは git submodule で `UniRx` パッケージを取得。
- プロジェクトの `.csproj` に `<PackageReference Include="UniRx" Version="7.*" />` を追加。
- `Godot` エディタの C# ビルド設定を更新し、依存関係を解決する。

## 2. クラスの Observable 化

- ゲームロジックやデータ管理クラスで状態変更を `IObservable` として公開する。
- 例として `ReactiveProperty<int> Health` を持つプレイヤークラスを実装。
- `Subject<T>` を用いて任意イベントをブロードキャストできる構造を準備する。

## 3. UI 更新から段階的に適用

1. HUD やメニュー表示を `ReactiveProperty` の変化で更新するよう改修。
2. 安定性を確認後、プレイヤーや敵のステート遷移にも同様のパターンを適用。

## 4. Telemetry ストリーム化と自動テスト連携

- KPI となるメトリクスを `Subject<T>` でストリーム化し、CI テストから購読できるようにする。
- ストリームは CSV への書き出しやログ送信などに接続可能とする。

## 5. サンプルコード

プロトタイプ用の簡易クラス `ReactiveCounter` を `res://Scripts/Reactive/ReactiveCounter.cs` に実装しています。
テスト用シーン `res://Scenes/ReactivePrototype.tscn` に配置済みで、ボタン操作で値を変更できます。

```csharp
using Godot;
using UniRx;

public partial class ReactiveCounter : Node
{
    public ReactiveProperty<int> Count { get; } = new ReactiveProperty<int>(0);

    public override void _Ready()
    {
        Count.Subscribe(value => GD.Print($"Count updated: {value}"));
    }

    public void Increment()
    {
        Count.Value++;
    }
}
```

上記クラスをシーンに配置し、`Increment()` を呼び出すことでカウント値が変化するたびにコンソールへ出力されます。

## 6. 進行計画

1. 開発環境で UniRx がビルド可能か確認。
2. 主要クラスを Observable 化し、HUD 更新とテレメトリ記録のプロトタイプを作成。
3. KPI 計測を踏まえ、パフォーマンスと可読性をレビュー。
4. 問題がなければ他システムへ拡大し、アーキテクチャ設計を確定する。

## 7. 変更履歴

| バージョン | 更新日     | 変更内容 |
| ---------- | ---------- | -------- |
| 0.1.0      | 2025-06-06 | 初版作成 |
